---
title: "what is kafka"

categories:
 - kafka
---

## kafka 탄생 배경

<figure class="align-left">
    <img src="{{site.baseurl}}/assets/img/apache_kafka_default.png" />
</figure>
카프카를 이해하기 위해서는 등장 배경을 먼저 설명하는 것이 좋습니다. 이미지와 같이 source system과 target system으로 구성되어 있는 아키텍쳐가 존재합니다. source system은 단순히 데이터를 전달하고 target system은  전달받는 곳을 뜻합니다. 

예를 들어 App -> MySQL로 데이터를 전송한다면 App은 source, MySQL은 Target이 됩니다. 다른 구성으로 MySQL -> Hadoop 으로 데이터를 전송시에는 MySQL이 source hadoop이 target이 됩니다.

<img src="{{site.baseurl}}/assets/img/apache_kafka_integration.png">
단순한 시스템이라면 문제가 없겠지만 엔터프라이즈급에서는 위와 같이 많은 수의 source system과 target system이 연동되어 있습니다. 최악의 경우를 생각한다면 source system 수 * target system이 될 것이며 각각의 프로토콜(HTTP, JDBC, SOCKET), 데이터 포멧(JSON, XML, CSV) 까지 고려한다면 굉장히 복잡한 시스템이 탄생할 것 입니다. 


<img src="{{site.baseurl}}/assets/img/apache_kafka_integration_with_kafka.png">
복잡도는 장애 및 운영상에 어려움을 야기하며 이러한 문제를 해결하기 위해 탄생한 것이 kafka 입니다.

## topic

데이터가 들어갈 수 있는 `공간` 이라고 생각할 수 있습니다.
토픽은 여러개 생성 될 수 있으며, 흡사 디렉토리 또는 폴더와 비슷한 개념으로 이해 할 수 있습니다.

producer는 카프카 토픽에 데이터를 적재하고 consumer는 적재된 데이터를 수신합니다.

## partition

하나의 토픽은 여러개의 partition으로 구성될 수 있습니다. partion은 숫자로 구분되며 0 부터 시작되며 독립적입니다. 

prdocuer 는 키를 지정하여 특정 partition으로 데이터를 전송할 수 있습니다. 만약, 키를 지정하지 않는다면 라운드로빈 방식으로 partition에 저장됩니다. 이때 데이터의 단위는 `Record` 라 합니다.

내부는 `queue` 형태로 구성되며 consumer는 가장 오래된 Record를 먼저 가져갑니다. consumer가  데이터를 가져가더라도 데이터가 삭제되진 않습니다. 옵션에 따라 다르며 용량 또는 기간에 따라 관리할 수 있습니다.

partition 사용시 주의할 점은 한번 늘어난 개수는 줄일 수 없다는 점 입니다.

## broker


## replication


## ISR